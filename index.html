<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Tree V5.1 (Better Photo Placement)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Arial', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* UI ç•Œé¢ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .hud-text {
            color: #FFD700; font-weight: bold; text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            font-size: 14px; letter-spacing: 1px;
        }

        #status-indicator { 
            font-size: 24px; font-weight: 800; color: #fff; text-align: center; margin-top: 10px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 20px;
            backdrop-filter: blur(4px); align-self: center;
        }
        
        /* è°ƒè¯•çª—å£ */
        .input_video { 
            position: absolute; bottom: 20px; left: 20px; width: 120px; height: 90px; 
            border: 2px solid #FFD700; transform: scaleX(-1); opacity: 0.8; border-radius: 8px; z-index: 20;
        }
        
        #upload-btn {
            pointer-events: auto; background: linear-gradient(45deg, #ff0044, #cc0033);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: #fff; padding: 12px 30px; cursor: pointer; border-radius: 30px;
            box-shadow: 0 4px 15px rgba(255, 0, 68, 0.4);
            font-weight: bold; align-self: center; margin-bottom: 40px;
            transition: transform 0.2s;
        }
        #upload-btn:active { transform: scale(0.95); }

        #hand-cursor {
            position: absolute; width: 50px; height: 50px;
            border: 3px solid #fff; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; display: none;
            box-shadow: 0 0 20px #fff, inset 0 0 10px #fff;
            z-index: 30; transition: width 0.2s, height 0.2s;
        }
        #hand-cursor.active { border-color: #ff0044; background: rgba(255, 0, 68, 0.2); width: 30px; height: 30px; }

        /* åŠ è½½é®ç½© */
        #loading-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; z-index: 100; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; color: white;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #FFD700; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="spinner"></div>
        <h3 id="loading-text">æ­£åœ¨è¿æ¥è§†è§‰å¼•æ“...</h3>
        <p style="font-size: 12px; color: #666; margin-top: 10px;">é¦–æ¬¡åŠ è½½çº¦éœ€ 10-30 ç§’ï¼Œè¯·ä¿æŒç½‘ç»œé€šç•…</p>
    </div>

    <div id="ui-layer">
        <div class="hud-text">V5.1 OPTIMIZED PLACEMENT</div>
        <div id="status-indicator">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤</div>
        <label id="upload-btn">
            ğŸ“· ä¸Šä¼ ç…§ç‰‡æŒ‚ä¸Šæ ‘
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
        </label>
    </div>

    <div id="hand-cursor"></div>
    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            count: 600,         
            colors: [0xffd700, 0xc0c0c0, 0xff0044, 0x1a472a],
            treeHeight: 35,
            treeRadius: 14,
            scatterRadius: 25,
            speed: 0.08         
        };

        const state = {
            mode: 'TREE', 
            handVisible: false,
            handPos: { x: 0.5, y: 0.5 },
            isPinching: false,
            activePhoto: null
        };

        // --- 1. åœºæ™¯ä¸å…‰ç…§ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012); 

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 5, 55);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3;
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffeebb, 1.5); 
        dirLight.position.set(20, 50, 20);
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(0xffd700, 2, 50); 
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        // --- 2. åæœŸå¤„ç† (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/2, window.innerHeight/2), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15; 
        bloomPass.strength = 1.3; 
        bloomPass.radius = 0.6;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. åœ£è¯æ ‘ç²’å­ç³»ç»Ÿ ---
        const geometry = new THREE.SphereGeometry(0.4, 16, 16);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff, roughness: 0.3, metalness: 0.8,
            emissive: 0x222222 
        });
        
        const instancedMesh = new THREE.InstancedMesh(geometry, material, CONFIG.count);
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(instancedMesh);

        const dummy = new THREE.Object3D();
        const targets = { tree: [], scatter: [] };

        // åˆå§‹åŒ–ç²’å­ä½ç½®
        const _color = new THREE.Color();
        for (let i = 0; i < CONFIG.count; i++) {
            const colorHex = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
            _color.setHex(colorHex);
            instancedMesh.setColorAt(i, _color);

            // æ ‘å½¢æ€ (i=0ä¸ºåº•éƒ¨, i=countä¸ºé¡¶éƒ¨)
            const hRatio = i / CONFIG.count;
            const r = (1 - hRatio) * CONFIG.treeRadius + 0.5;
            const theta = i * 0.8; 
            const y = hRatio * CONFIG.treeHeight - CONFIG.treeHeight/2;
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            targets.tree.push(new THREE.Vector3(x, y, z));

            // æ•£å¼€å½¢æ€
            const sr = CONFIG.scatterRadius * Math.cbrt(Math.random());
            const phi = Math.acos(2 * Math.random() - 1);
            const sa = 2 * Math.PI * Math.random();
            targets.scatter.push(new THREE.Vector3(
                sr * Math.sin(phi) * Math.cos(sa),
                sr * Math.sin(phi) * Math.sin(sa),
                sr * Math.cos(phi)
            ));
            
            dummy.position.set(x, y, z);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(i, dummy.matrix);
        }
        instancedMesh.instanceColor.needsUpdate = true;
        const currentPositions = targets.tree.map(v => v.clone());

        // --- 4. ğŸŒŸ é‡‘è‰²é¡¶æ˜Ÿ ---
        function createTopStar() {
            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = 2.0; 
            const innerRadius = 0.8; 

            for (let i = 0; i < points * 2; i++) {
                const angle = (i / points) * Math.PI;
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                if (i === 0) shape.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                else shape.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
            }
            shape.closePath();

            const starGeo = new THREE.ExtrudeGeometry(shape, {
                depth: 0.5, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.1, bevelSegments: 2
            });
            starGeo.center();

            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffaa00,
                emissiveIntensity: 2.0, 
                metalness: 1.0,
                roughness: 0.1
            });

            const mesh = new THREE.Mesh(starGeo, starMat);
            mesh.userData = {
                treePos: new THREE.Vector3(0, CONFIG.treeHeight / 2 + 1.5, 0),
                scatterPos: new THREE.Vector3(0, 10, 0), 
                rotationSpeed: 0.02
            };
            
            scene.add(mesh);
            return mesh;
        }
        const topStar = createTopStar();

        // --- 5. ç…§ç‰‡å¢™é€»è¾‘ (å·²ä¼˜åŒ–æ’åˆ—) ---
        const photos = [];
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);
        const photoGeo = new THREE.PlaneGeometry(3, 4);

        function createPhoto(texture, index) {
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(photoGeo, mat);
            
            // --- æ ¸å¿ƒä¿®æ”¹ï¼šé™åˆ¶ç…§ç‰‡ç”Ÿæˆé«˜åº¦ ---
            // æˆ‘ä»¬åªä»æ ‘çš„ä¸‹ 70% çš„ç²’å­ä¸­éšæœºé€‰æ‹©ä½ç½®æŒ‚è½½ç…§ç‰‡
            // è¿™æ ·å¯ä»¥ç¡®ä¿ç…§ç‰‡ä¸ä¼šå‡ºç°åœ¨æ ‘çš„é¡¶éƒ¨åŒºåŸŸ
            const maxAllowedIndex = Math.floor(CONFIG.count * 0.7); 
            const idx = Math.floor(Math.random() * maxAllowedIndex);
            
            // è·å–è¯¥ç²’å­çš„ä½ç½®ï¼Œå¹¶å‘å¤–æ¨ä¸€ç‚¹
            const treePos = targets.tree[idx].clone().multiplyScalar(1.25);
            const scatterPos = targets.scatter[idx].clone();

            mesh.userData = {
                treePos: treePos,
                scatterPos: scatterPos,
                originalScale: 1
            };
            mesh.position.copy(treePos);
            // è®©ç…§ç‰‡ç¨å¾®æœä¸Šä¸€ç‚¹ï¼Œçœ‹èµ·æ¥æ›´è‡ªç„¶
            mesh.lookAt(0, treePos.y + 5, 0);
            
            photoGroup.add(mesh);
            photos.push(mesh);
        }

        for(let i=0; i<8; i++) {
            const cvs = document.createElement('canvas');
            cvs.width=200; cvs.height=300;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = `hsl(${Math.random()*360}, 70%, 40%)`; // ç¨å¾®æ·±ä¸€ç‚¹çš„é¢œè‰²
            ctx.fillRect(0,0,200,300);
            ctx.fillStyle='white'; ctx.font='40px Arial'; ctx.fillText('Photo', 40, 150);
            createPhoto(new THREE.CanvasTexture(cvs), i);
        }

        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(!files.length) return;
            new THREE.TextureLoader().load(URL.createObjectURL(files[0]), (tex) => {
                createPhoto(tex, photos.length);
                state.mode = 'SCATTER'; 
            });
        });

        // --- 6. åŠ¨ç”»å¾ªç¯ ---
        const raycaster = new THREE.Raycaster();
        
        function animate() {
            requestAnimationFrame(animate);

            // A. æ˜Ÿæ˜ŸåŠ¨ç”»
            if (topStar) {
                const target = state.mode === 'TREE' ? topStar.userData.treePos : topStar.userData.scatterPos;
                topStar.position.lerp(target, CONFIG.speed);
                topStar.rotation.y += topStar.userData.rotationSpeed;
                if (state.mode === 'SCATTER') {
                    topStar.rotation.z += 0.01;
                    topStar.rotation.x += 0.01;
                } else {
                    topStar.rotation.z *= 0.9; 
                    topStar.rotation.x *= 0.9;
                }
            }

            // B. ç²’å­åŠ¨ç”»
            const targetArr = state.mode === 'TREE' ? targets.tree : targets.scatter;
            for (let i = 0; i < CONFIG.count; i++) {
                const current = currentPositions[i];
                const target = targetArr[i];
                
                current.x += (target.x - current.x) * CONFIG.speed;
                current.y += (target.y - current.y) * CONFIG.speed;
                current.z += (target.z - current.z) * CONFIG.speed;

                dummy.position.copy(current);
                if(state.mode === 'SCATTER') dummy.rotation.set(current.x, current.y, 0);
                else dummy.rotation.set(0,0,0);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            instancedMesh.instanceMatrix.needsUpdate = true;

            // C. ç…§ç‰‡åŠ¨ç”»
            photos.forEach(photo => {
                let target;
                if(state.activePhoto === photo) {
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    target = camera.position.clone().add(camDir.multiplyScalar(10));
                    photo.lookAt(camera.position);
                    photo.scale.setScalar(THREE.MathUtils.lerp(photo.scale.x, 2.5, 0.1));
                } else {
                    target = (state.mode === 'TREE') ? photo.userData.treePos : photo.userData.scatterPos;
                    // æ ‘å½¢æ€ä¸‹ï¼Œè®©ç…§ç‰‡é¢æœå¤–å¹¶ç¨å¾®å‘ä¸Š
                    if (state.mode === 'TREE') {
                         photo.lookAt(0, photo.position.y + 5, 0);
                    } else {
                         photo.lookAt(0,0,0);
                    }
                    photo.scale.setScalar(THREE.MathUtils.lerp(photo.scale.x, 1, 0.1));
                }
                photo.position.lerp(target, CONFIG.speed);
            });

            // D. ç›¸æœºäº¤äº’
            if(state.handVisible && state.mode === 'SCATTER' && !state.activePhoto) {
                const targetX = (state.handPos.x - 0.5) * 80;
                const targetY = (0.5 - state.handPos.y) * 40;
                camera.position.x += (targetX - camera.position.x) * 0.05;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            }

            composer.render();
        }
        animate();

        // --- 7. MediaPipe (ä¿æŒä¸å˜) ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusDiv = document.getElementById('status-indicator');
        const cursor = document.getElementById('hand-cursor');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');

        setTimeout(() => {
            if(loadingScreen.style.display !== 'none') {
                loadingText.innerHTML = "âš ï¸ åŠ è½½è¿‡æ…¢<br>è¯·æ£€æŸ¥ç½‘ç»œæˆ–ç‚¹å‡»å…è®¸æ‘„åƒå¤´";
            }
        }, 15000);

        function onResults(results) {
            if(loadingScreen.style.display !== 'none') loadingScreen.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handVisible = true;
                const lm = results.multiHandLandmarks[0];
                
                const x = (lm[0].x + lm[5].x + lm[17].x) / 3;
                const y = (lm[0].y + lm[5].y + lm[17].y) / 3;
                state.handPos = {x, y};

                cursor.style.display = 'block';
                cursor.style.left = `${(1-x)*100}%`;
                cursor.style.top = `${y*100}%`;

                const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                const isFist = Math.hypot(lm[12].y - lm[0].y) < 0.25; 

                if (pinchDist < 0.08) {
                    state.isPinching = true;
                    cursor.classList.add('active');
                    statusDiv.innerText = "çŠ¶æ€: ğŸ¤ é€‰ä¸­/æ”¾å¤§";
                    checkInteraction((1-x)*2-1, -y*2+1);
                } else {
                    state.isPinching = false;
                    cursor.classList.remove('active');
                    state.activePhoto = null; 

                    if (isFist) {
                        state.mode = 'TREE';
                        statusDiv.innerText = "çŠ¶æ€: âœŠ èšåˆ";
                    } else {
                        state.mode = 'SCATTER';
                        statusDiv.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€/æ—‹è½¬";
                    }
                }
            } else {
                state.handVisible = false;
                cursor.style.display = 'none';
                statusDiv.innerText = "è¯·å°†æ‰‹æ”¾å…¥æ‘„åƒå¤´èŒƒå›´";
            }
        }

        function checkInteraction(x, y) {
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            const intersects = raycaster.intersectObjects(photos);
            if(intersects.length > 0) {
                state.activePhoto = intersects[0].object;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://unpkg.com/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, 
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240 
        });
        
        try {
            cameraUtils.start();
        } catch(e) {
            loadingText.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·å…è®¸æƒé™";
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>