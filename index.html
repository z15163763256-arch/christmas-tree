<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Christmas Tree V4.0 (High Performance)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Arial', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* UI ç•Œé¢ä¼˜åŒ– */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .hud-text {
            color: #FFD700; font-weight: bold; text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            font-size: 14px; letter-spacing: 1px;
        }

        #status-indicator { 
            font-size: 24px; font-weight: 800; color: #fff; text-align: center; margin-top: 10px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 20px;
            backdrop-filter: blur(4px); align-self: center;
        }
        
        /* è°ƒè¯•çª—å£ */
        .input_video { 
            position: absolute; bottom: 20px; left: 20px; width: 120px; height: 90px; 
            border: 2px solid #FFD700; transform: scaleX(-1); opacity: 0.8; border-radius: 8px; z-index: 20;
        }
        
        #upload-btn {
            pointer-events: auto; background: linear-gradient(45deg, #ff0044, #cc0033);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: #fff; padding: 12px 30px; cursor: pointer; border-radius: 30px;
            box-shadow: 0 4px 15px rgba(255, 0, 68, 0.4);
            font-weight: bold; align-self: center; margin-bottom: 40px;
            transition: transform 0.2s;
        }
        #upload-btn:active { transform: scale(0.95); }

        #hand-cursor {
            position: absolute; width: 50px; height: 50px;
            border: 3px solid #fff; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; display: none;
            box-shadow: 0 0 20px #fff, inset 0 0 10px #fff;
            z-index: 30; transition: width 0.2s, height 0.2s;
        }
        #hand-cursor.active { border-color: #ff0044; background: rgba(255, 0, 68, 0.2); width: 30px; height: 30px; }

        /* åŠ è½½é®ç½© */
        #loading-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; z-index: 100; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; color: white;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #FFD700; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="spinner"></div>
        <h3 id="loading-text">æ­£åœ¨è¿æ¥è§†è§‰å¼•æ“...</h3>
        <p style="font-size: 12px; color: #666; margin-top: 10px;">é¦–æ¬¡åŠ è½½çº¦éœ€ 10-30 ç§’ï¼Œè¯·ä¿æŒç½‘ç»œé€šç•…</p>
    </div>

    <div id="ui-layer">
        <div class="hud-text">V4.0 HIGH PERFORMANCE</div>
        <div id="status-indicator">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤</div>
        <label id="upload-btn">
            ğŸ“· ä¸Šä¼ ç…§ç‰‡æŒ‚ä¸Šæ ‘
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
        </label>
    </div>

    <div id="hand-cursor"></div>
    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            count: 600,         // ç²’å­æ€»æ•°
            photoLimit: 20,     // ç…§ç‰‡æœ€å¤§æ•°é‡
            colors: [0xffd700, 0xc0c0c0, 0xff0044, 0x1a472a], // é‡‘, é“¶, çº¢, ç»¿
            treeHeight: 35,
            treeRadius: 14,
            scatterRadius: 25,
            speed: 0.08         // åŠ¨ç”»é€Ÿåº¦ç³»æ•°
        };

        const state = {
            mode: 'TREE', // TREE, SCATTER, ZOOM
            handVisible: false,
            handPos: { x: 0.5, y: 0.5 },
            isPinching: false,
            activePhoto: null
        };

        // --- 1. åœºæ™¯ä¸é«˜äº®å…‰ç…§ (è§£å†³ç”»é¢æš—) ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.012); // é»‘èƒŒæ™¯é…åˆé›¾æ°”

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 5, 55);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        // æ€§èƒ½ä¼˜åŒ–ï¼šé™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢4Kå±å¡é¡¿
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        // è‰²è°ƒæ˜ å°„ä¼˜åŒ–ï¼šè®©äº®éƒ¨æ›´äº®
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3;
        container.appendChild(renderer.domElement);

        // ç¯å…‰åŠ å¼º
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // ç¯å¢ƒå…‰å¢å¼º
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffeebb, 1.5); // ä¸»å…‰æº
        dirLight.position.set(20, 50, 20);
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(0xffd700, 2, 50); // å±€éƒ¨è¡¥å…‰
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        // --- 2. åæœŸå¤„ç† (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        // åˆ†è¾¨ç‡å‡åŠä»¥æå‡æ€§èƒ½
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/2, window.innerHeight/2), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15; // é˜ˆå€¼é™ä½ï¼Œæ›´å®¹æ˜“å‘å…‰
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.6;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. å®ä¾‹åŒ–æ¸²æŸ“ (è§£å†³å¡é¡¿) ---
        // ä½¿ç”¨ InstancedMesh ä¸€æ¬¡æ€§æ¸²æŸ“æ•°ç™¾ä¸ªçƒä½“
        const geometry = new THREE.SphereGeometry(0.4, 16, 16);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff, roughness: 0.3, metalness: 0.8,
            emissive: 0x222222 // è‡ªå‘å…‰ï¼Œé˜²æ­¢å¤ªæš—
        });
        
        const instancedMesh = new THREE.InstancedMesh(geometry, material, CONFIG.count);
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(instancedMesh);

        // é¢„è®¡ç®—æ•°æ®
        const dummy = new THREE.Object3D();
        const colorsData = [];
        const targets = {
            tree: [],
            scatter: []
        };

        // åˆå§‹åŒ–ä½ç½®æ•°æ®
        const _color = new THREE.Color();
        for (let i = 0; i < CONFIG.count; i++) {
            // é¢œè‰²
            const colorHex = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
            _color.setHex(colorHex);
            instancedMesh.setColorAt(i, _color);
            colorsData.push(_color.clone());

            // æ ‘å½¢æ€åæ ‡ (åœ†é”¥èºæ—‹)
            const hRatio = i / CONFIG.count;
            const r = (1 - hRatio) * CONFIG.treeRadius + 0.5;
            const theta = i * 0.8; 
            const y = hRatio * CONFIG.treeHeight - CONFIG.treeHeight/2;
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            targets.tree.push(new THREE.Vector3(x, y, z));

            // æ•£å¼€å½¢æ€åæ ‡ (éšæœºçƒä½“)
            const sr = CONFIG.scatterRadius * Math.cbrt(Math.random());
            const phi = Math.acos(2 * Math.random() - 1);
            const sa = 2 * Math.PI * Math.random();
            targets.scatter.push(new THREE.Vector3(
                sr * Math.sin(phi) * Math.cos(sa),
                sr * Math.sin(phi) * Math.sin(sa),
                sr * Math.cos(phi)
            ));
            
            // åˆå§‹è®¾ä¸ºæ ‘
            dummy.position.set(x, y, z);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(i, dummy.matrix);
        }
        instancedMesh.instanceColor.needsUpdate = true;

        // å½“å‰ç²’å­çš„å®æ—¶ä½ç½®æ•°ç»„
        const currentPositions = targets.tree.map(v => v.clone());

        // --- 4. ç…§ç‰‡å¢™é€»è¾‘ (ç‹¬ç«‹Mesh) ---
        const photos = [];
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);
        const photoGeo = new THREE.PlaneGeometry(3, 4);

        function createPhoto(texture, index) {
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(photoGeo, mat);
            
            // éšæœºæŒ‚è½½ç‚¹
            const idx = Math.floor(Math.random() * CONFIG.count);
            const treePos = targets.tree[idx].clone().multiplyScalar(1.2); // ç¨å¾®é å¤–
            const scatterPos = targets.scatter[idx].clone();

            mesh.userData = {
                treePos: treePos,
                scatterPos: scatterPos,
                originalScale: 1
            };
            mesh.position.copy(treePos);
            mesh.lookAt(0,0,0);
            photoGroup.add(mesh);
            photos.push(mesh);
        }

        // é»˜è®¤ç”Ÿæˆå‡ å¼ è‰²å—å›¾
        for(let i=0; i<8; i++) {
            const cvs = document.createElement('canvas');
            cvs.width=200; cvs.height=300;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = `hsl(${Math.random()*360}, 70%, 50%)`;
            ctx.fillRect(0,0,200,300);
            ctx.fillStyle='white'; ctx.font='40px Arial'; ctx.fillText('Photo', 40, 150);
            createPhoto(new THREE.CanvasTexture(cvs), i);
        }

        // ä¸Šä¼ å¤„ç†
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if(!files.length) return;
            new THREE.TextureLoader().load(URL.createObjectURL(files[0]), (tex) => {
                createPhoto(tex, photos.length);
                state.mode = 'SCATTER'; // ä¸Šä¼ åè‡ªåŠ¨æ•£å¼€
            });
        });

        // --- 5. åŠ¨ç”»å¾ªç¯ (é«˜æ•ˆæ’å€¼) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function animate() {
            requestAnimationFrame(animate);

            // A. ç²’å­åŠ¨ç”» (InstancedMesh æ›´æ–°)
            const targetArr = state.mode === 'TREE' ? targets.tree : targets.scatter;
            
            for (let i = 0; i < CONFIG.count; i++) {
                const current = currentPositions[i];
                const target = targetArr[i];
                
                // å¿«é€Ÿæ’å€¼
                current.x += (target.x - current.x) * CONFIG.speed;
                current.y += (target.y - current.y) * CONFIG.speed;
                current.z += (target.z - current.z) * CONFIG.speed;

                // ç®€å•çš„è‡ªæ—‹è½¬æ•ˆæœ (é€šè¿‡ä½ç½®å¾®è°ƒæ¨¡æ‹Ÿ)
                dummy.position.copy(current);
                if(state.mode === 'SCATTER') dummy.rotation.set(current.x, current.y, 0);
                else dummy.rotation.set(0,0,0);
                
                dummy.scale.setScalar(1); // ä¿æŒå¤§å°
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            instancedMesh.instanceMatrix.needsUpdate = true;

            // B. ç…§ç‰‡åŠ¨ç”»
            photos.forEach(photo => {
                let target;
                if(state.activePhoto === photo) {
                    // é€‰ä¸­æ”¾å¤§æ¨¡å¼
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    target = camera.position.clone().add(camDir.multiplyScalar(10));
                    photo.lookAt(camera.position);
                    photo.scale.setScalar(THREE.MathUtils.lerp(photo.scale.x, 2.5, 0.1));
                } else {
                    target = (state.mode === 'TREE') ? photo.userData.treePos : photo.userData.scatterPos;
                    photo.lookAt(0,0,0);
                    photo.scale.setScalar(THREE.MathUtils.lerp(photo.scale.x, 1, 0.1));
                }
                photo.position.lerp(target, CONFIG.speed);
            });

            // C. ç›¸æœºäº¤äº’
            if(state.handVisible && state.mode === 'SCATTER' && !state.activePhoto) {
                const targetX = (state.handPos.x - 0.5) * 80;
                const targetY = (0.5 - state.handPos.y) * 40;
                camera.position.x += (targetX - camera.position.x) * 0.05;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            }

            composer.render();
        }
        animate();

        // --- 6. MediaPipe é€»è¾‘ (ä¼˜åŒ–åŠ è½½) ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusDiv = document.getElementById('status-indicator');
        const cursor = document.getElementById('hand-cursor');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');

        // è¶…æ—¶æ£€æµ‹
        setTimeout(() => {
            if(loadingScreen.style.display !== 'none') {
                loadingText.innerHTML = "âš ï¸ åŠ è½½è¿‡æ…¢<br>è¯·æ£€æŸ¥ç½‘ç»œæˆ–ç‚¹å‡»å…è®¸æ‘„åƒå¤´";
            }
        }, 15000);

        function onResults(results) {
            // é¦–æ¬¡æˆåŠŸå›è°ƒï¼Œéšè—åŠ è½½å±‚
            if(loadingScreen.style.display !== 'none') loadingScreen.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handVisible = true;
                const lm = results.multiHandLandmarks[0];
                
                // è®¡ç®—æ‰‹æŒä¸­å¿ƒ
                const x = (lm[0].x + lm[5].x + lm[17].x) / 3;
                const y = (lm[0].y + lm[5].y + lm[17].y) / 3;
                state.handPos = {x, y};

                // å…‰æ ‡è·Ÿéš
                cursor.style.display = 'block';
                cursor.style.left = `${(1-x)*100}%`;
                cursor.style.top = `${y*100}%`;

                // åŠ¨ä½œæ£€æµ‹
                const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                const isFist = Math.hypot(lm[12].y - lm[0].y) < 0.25; // ç®€å•æ¡æ‹³æ£€æµ‹

                // çŠ¶æ€æœº
                if (pinchDist < 0.08) {
                    state.isPinching = true;
                    cursor.classList.add('active');
                    statusDiv.innerText = "çŠ¶æ€: ğŸ¤ é€‰ä¸­/æ”¾å¤§";
                    checkInteraction((1-x)*2-1, -y*2+1);
                } else {
                    state.isPinching = false;
                    cursor.classList.remove('active');
                    state.activePhoto = null; // é‡Šæ”¾ç…§ç‰‡

                    if (isFist) {
                        state.mode = 'TREE';
                        statusDiv.innerText = "çŠ¶æ€: âœŠ èšåˆ";
                    } else {
                        state.mode = 'SCATTER';
                        statusDiv.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€/æ—‹è½¬";
                    }
                }
            } else {
                state.handVisible = false;
                cursor.style.display = 'none';
                statusDiv.innerText = "è¯·å°†æ‰‹æ”¾å…¥æ‘„åƒå¤´èŒƒå›´";
            }
        }

        // å°„çº¿æ£€æµ‹
        function checkInteraction(x, y) {
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            const intersects = raycaster.intersectObjects(photos);
            if(intersects.length > 0) {
                state.activePhoto = intersects[0].object;
            }
        }

        // åˆå§‹åŒ– MediaPipe
        const hands = new Hands({locateFile: (file) => {
            // ä½¿ç”¨ unpkg æºï¼Œé€šå¸¸æ¯” jsdelivr æ›´ç¨³
            return `https://unpkg.com/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // é™ä½æ¨¡å‹ç²¾åº¦ä»¥æ¢å–é€Ÿåº¦
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240 // é™ä½æ‘„åƒå¤´åˆ†è¾¨ç‡å¤„ç†ï¼Œæå¤§æå‡æ€§èƒ½
        });
        
        try {
            cameraUtils.start();
        } catch(e) {
            loadingText.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·å…è®¸æƒé™";
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>